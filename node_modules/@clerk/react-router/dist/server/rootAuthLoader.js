// src/server/rootAuthLoader.ts
import { decorateObjectWithResources } from "@clerk/backend/internal";
import { logger } from "@clerk/shared/logger";
import { invalidRootLoaderCallbackReturn, middlewareMigrationWarning } from "../utils/errors.js";
import { authFnContext, requestStateContext } from "./clerkMiddleware.js";
import { legacyAuthenticateRequest } from "./legacyAuthenticateRequest.js";
import { loadOptions } from "./loadOptions.js";
import {
  getResponseClerkState,
  injectRequestStateIntoResponse,
  isDataWithResponseInit,
  IsOptIntoMiddleware,
  isRedirect,
  isResponse
} from "./utils.js";
async function processRootAuthLoader(args, requestState, handler) {
  var _a;
  const hasMiddleware = IsOptIntoMiddleware(args.context) && !!args.context.get(authFnContext);
  const includeClerkHeaders = !hasMiddleware;
  if (!handler) {
    const { clerkState: clerkState2 } = getResponseClerkState(requestState, args.context);
    return {
      ...clerkState2
    };
  }
  const argsWithAuth = {
    ...args,
    request: Object.assign(args.request, { auth: requestState.toAuth() })
  };
  const handlerResult = await handler(argsWithAuth);
  if (isResponse(handlerResult)) {
    try {
      if (isRedirect(handlerResult)) {
        return handlerResult;
      }
      return injectRequestStateIntoResponse(handlerResult, requestState, args.context, includeClerkHeaders);
    } catch {
      throw new Error(invalidRootLoaderCallbackReturn);
    }
  }
  if (isDataWithResponseInit(handlerResult)) {
    try {
      return injectRequestStateIntoResponse(
        new Response(JSON.stringify(handlerResult.data), (_a = handlerResult.init) != null ? _a : void 0),
        requestState,
        args.context,
        includeClerkHeaders
      );
    } catch {
      throw new Error(invalidRootLoaderCallbackReturn);
    }
  }
  if (includeClerkHeaders) {
    const responseBody = JSON.stringify(handlerResult != null ? handlerResult : {});
    return injectRequestStateIntoResponse(new Response(responseBody), requestState, args.context, includeClerkHeaders);
  }
  const { clerkState } = getResponseClerkState(requestState, args.context);
  return {
    ...handlerResult != null ? handlerResult : {},
    ...clerkState
  };
}
var rootAuthLoader = async (args, handlerOrOptions, options) => {
  const handler = typeof handlerOrOptions === "function" ? handlerOrOptions : void 0;
  const opts = options ? options : !!handlerOrOptions && typeof handlerOrOptions !== "function" ? handlerOrOptions : {};
  const hasMiddlewareFlag = IsOptIntoMiddleware(args.context);
  const requestState = hasMiddlewareFlag && args.context.get(requestStateContext);
  if (!requestState) {
    logger.warnOnce(middlewareMigrationWarning);
    return legacyRootAuthLoader(args, handlerOrOptions, opts);
  }
  return processRootAuthLoader(args, requestState, handler);
};
var legacyRootAuthLoader = async (args, handlerOrOptions, options) => {
  const handler = typeof handlerOrOptions === "function" ? handlerOrOptions : void 0;
  const opts = options ? options : !!handlerOrOptions && typeof handlerOrOptions !== "function" ? handlerOrOptions : {};
  const loadedOptions = loadOptions(args, opts);
  const _requestState = await legacyAuthenticateRequest(args, loadedOptions);
  const requestState = { ...loadedOptions, ..._requestState };
  if (!handler) {
    return injectRequestStateIntoResponse(new Response(JSON.stringify({})), requestState, args.context, true);
  }
  const authObj = requestState.toAuth();
  const requestWithAuth = Object.assign(args.request, { auth: authObj });
  await decorateObjectWithResources(requestWithAuth, authObj, loadedOptions);
  return processRootAuthLoader(args, requestState, handler);
};
export {
  rootAuthLoader
};
//# sourceMappingURL=rootAuthLoader.js.map